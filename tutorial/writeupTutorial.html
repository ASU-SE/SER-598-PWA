<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progressive Web Applications (PWAs) - Comprehensive Tutorial</title>
</head>
<body>
    <h1>Progressive Web Applications (PWAs): A Comprehensive Tutorial</h1>
    <h2>SER-598</h2>
    <p><strong>Authors:</strong> Arunkumar Gangula, Bhawan Chinavada, Joshua Dsouza, Piyush Sharma</p>

    <h2>Table of Contents</h2>
    <ul>
        <li><a href="#introduction">1. Introduction</a></li>
        <li><a href="#learning-outcomes">2. Learning Outcomes</a></li>
        <li><a href="#what-is-pwa">3. What is a PWA?</a></li>
        <li><a href="#history">4. History of PWAs</a></li>
        <li><a href="#browser-support">5. Browser Support</a></li>
        <li><a href="#tutorial">6. Hands-on Tutorial: Building a Study Sync PWA</a></li>
        <li><a href="#technologies">7. Technologies Used</a></li>
        <li><a href="#prerequisites">8. Prerequisites</a></li>
        <li><a href="#setup">9. Step-by-step Guide</a></li>
        <ul>
            <li><a href="#setup">9.1 Setting Up the Project</a></li>
        </ul>
        <li><a href="#manifest">10. Manifest File for PWAs</a></li>
        <ul>
            <li><a href="#manifest">10.1 Basic Properties in a Manifest File</a></li>
            <li><a href="#manifest">10.2 Defining the manifest file for the StudySync PWA</a></li>
            <li><a href="#manifest">10.3 Integrate the manifest file in the PWA</a></li>
        </ul>
        <li><a href="#service-worker">11. Service Worker for PWAs</a></li>
        <ul>
            <li><a href="#service-worker">11.1 Lifecycle of a Service Worker</a></li>
            <li><a href="#service-worker">11.2 Integrate Service Worker into StudySync PWA</a></li>
        </ul>
        <li><a href="#android">12. Running the Project on Android Emulator</a></li>
        <ul>
            <li><a href="#android">12.1 Prerequisites</a></li>
            <li><a href="#android">12.2 Setting Up Android Studio and AVD</a></li>
            <li><a href="#android">12.3 Testing the PWA</a></li>
        </ul>
        <li><a href="#caching">13. Service Worker Caching and Fetch Handling</a></li>
        <ul>
            <li><a href="#caching">13.1 Cache Configuration</a></li>
            <li><a href="#caching">13.2 Enhanced Installation Phase</a></li>
            <li><a href="#caching">13.3 Cache Management During Activation</a></li>
            <li><a href="#caching">13.4 Fetch Request Handling</a></li>
            <li><a href="#caching">13.5 Caching Strategy Explanation</a></li>
            <li><a href="#caching">13.6 Testing Cache Implementation</a></li>
        </ul>
        <li><a href="#offline-storage">14. Implementing Offline Storage with IndexedDB</a></li>
        <ul>
            <li><a href="#offline-storage">14.1 Database Manager Implementation</a></li>
            <li><a href="#offline-storage">14.2 Modified FlashcardManager for Offline Support</a></li>
        </ul>
        <li><a href="#sync-service">15. Implementing Sync Service and Application Architecture</a></li>
        <ul>
            <li><a href="#sync-service">15.1 Sync Service Implementation</a></li>
            <li><a href="#sync-service">15.2 Enhanced Application Architecture</a></li>
            <li><a href="#sync-service">15.3 Key Components and Their Interactions</a></li>
            <li><a href="#sync-service">15.4 Component Interaction Diagram</a></li>
        </ul>
        <li><a href="#references">16. References</a></li>
    </ul>

    <h2 id="introduction">1. Introduction</h2>
    <p>Welcome to the tutorial on progressive web applications. The need for apps that offer a smooth user experience across all platforms is growing daily in the modern world due to the advancement of digital technology and the ease of use of mobile phones. Nevertheless, the native application experience and the web application experience, whether on a desktop or mobile device, differ significantly.</p>
    <p>PWAs, or progressive web applications, are designed to fill the gap between these two. They are attempting to provide the user with the best of both worlds. While learning about the benefits of this technology, this tutorial will walk you through the basic ideas of PWAs and show you how to create a PWA application from scratch.</p>

    <h2 id="learning-outcomes">2. Learning Outcomes</h2>
    <p>After completing this tutorial, you will have a good understanding of:</p>
    <ul>
        <li>What is PWA and what are the key components of PWA.</li>
        <li>How to create a fully functional PWA from scratch or convert an existing web application to PWA.</li>
        <li>Implementation of web app manifests and service workers from scratch, which are the essential components of PWA.</li>
        <li>How to make your web application installable on a desktop.</li>
        <li>How to enable offline functionality in your app.</li>
        <li>Integration of push notifications.</li>
        <li>Testing your application using developer tools on a browser and an Android emulator.</li>
        <li>Analyze the performance of your PWA app.</li>
    </ul>

    <h2 id="what-is-pwa">3. What is a PWA?</h2>
    <p>Progressive Web Applications are web applications that are designed to deliver an experience like native apps to the users. They utilize the modern browser and web capabilities to provide this experience. They combine features of web and native mobile applications.</p>
    <p>Some key features of PWAs are:</p>
    <ul>
        <li><strong>Responsive Design:</strong> PWAs work seamlessly on different devices with different screen sizes. They adjust dynamically to the screen layout.</li>
        <li><strong>Installability:</strong> PWAs can be directly installed by users from their browsers to their device's home screens, making the application easily accessible.</li>
        <li><strong>Offline Functionality:</strong> PWAs cache resources and provide a seamless experience even when the user is offline.</li>
        <li><strong>Native Features:</strong> PWAs can access native features and device hardware capabilities, such as push notifications.</li>
    </ul>

    <h2 id="history">4. History of PWAs</h2>
    <p>The concept of Progressive Web Applications has evolved over several years:</p>
    <ul>
        <li><strong>2007:</strong> Steve Jobs coined the concept of Web 2.0 during the iPhone launch, suggesting web apps for iPhone. Later, native app development took precedence.</li>
        <li><strong>2010-2012:</strong> With media queries and flexible layouts, responsive design became popular but lacked native app functionalities.</li>
        <li><strong>2015:</strong> Alex Russel from Google Chrome officially coined the term <em>Progressive Web Apps</em> and set principles for what defines a PWA.</li>
    </ul>

    <h2 id="browser-support">5. Browser Support</h2>
    <p>Browser support for PWAs has grown significantly:</p>
    <ul>
        <li><strong>Mobile Browsers:</strong> Firefox, Chrome, Edge, Opera, and Samsung Internet Browser support PWAs on Android. iOS extends support to Safari, Chrome, and Firefox in versions 16.4 and later.</li>
        <li><strong>Desktop Browsers:</strong> Chromium-based browsers support PWA installation. Firefox and Safari do not support PWA installation.</li>
    </ul>

    <h2 id="tutorial">6. Hands-on Tutorial: Building a Study Sync PWA</h2>
    <p>In this tutorial, we will build a simple PWA application called <strong>Study Sync</strong>. This application helps students manage flashcards for their studies. Key features include:</p>
    <ul>
        <li>User-friendly interface for managing flashcards.</li>
        <li>Ability to set reminders for study sessions.</li>
        <li>Offline access through caching mechanisms.</li>
    </ul>
    <p>This tutorial focuses on PWA core components and does not dive deep into frontend or backend development.</p>

    <h2 id="technologies-used">7. Technologies Used</h2>
    <p>To build the Study Sync PWA, we will use:</p>
    <ul>
        <li><strong>Frontend Technologies:</strong> HTML, CSS, and JavaScript.</li>
        <li><strong>Backend Framework:</strong> Spring Boot for server-side logic and RESTful API interactions.</li>
        <li><strong>Optional:</strong> Docker for containerized deployment.</li>
    </ul>

    <h2 id="prerequisites">8. Prerequisites</h2>
    <p>To follow this tutorial, you should have:</p>
    <ul>
        <li>A basic understanding of HTML, CSS, and JavaScript.</li>
        <li>Knowledge of HTTPS and responsive design principles.</li>
        <li>Java 21 installed on your machine for backend support.</li>
    </ul>

    <h2 id="setup">9. Step-by-step Guide</h2>
    <h3>9.1 Setting Up the Project</h3>
    <p>To get started, clone the repository:</p>
    <pre><code>git clone https://github.com/ASU-SE/SER-598-PWA.git</code></pre>
    <p>Navigate to the project directory:</p>
    <pre><code>cd SER-598-PWA/flashcardWithoutPWAForTutorial</code></pre>
    <p>Run the project using Gradle:</p>
    <pre><code>./gradlew bootRun</code></pre>
    <p>Or using Docker:</p>
    <pre><code>docker build -t study-sync .
docker run -d -p 8080:8080 --name my-springboot-container study-sync</code></pre>
    <p>Visit <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> to see the application running.</p>

    <h2 id="manifest">10. Manifest File for Progressive Web Apps</h2>
    <p>The manifest file is an important part of building a Progressive Web App (PWA). It tells the browser all about your PWA, such as the app name, the entry point page, and how it should look or behave. The manifest file is written in JSON format and includes various properties.</p>
    
    <h3>10.1 Basic Properties in a Manifest File</h3>
    <p>Below are the basic properties needed in a manifest file:</p>
    <ul>
        <li><strong>name:</strong> The full name of your application.</li>
        <li><strong>short_name:</strong> A shorter version of the app name, used when the full name is too long.</li>
        <li><strong>start_url:</strong> The page the app will open when launched. Example: <code>https://myapp.com/index.html</code></li>
        <li><strong>display:</strong> Controls the app's appearance when opened. Options:
            <ul>
                <li><code>fullscreen</code>: Uses the entire screen with no browser UI.</li>
                <li><code>standalone</code>: Makes the app look like a mobile app.</li>
                <li><code>minimal-ui</code>: Shows minimal browser elements for navigation.</li>
                <li><code>browser</code>: Opens in a regular browser window.</li>
            </ul>
        </li>
        <li><strong>background_color:</strong> The background color displayed while the app is loading.</li>
        <li><strong>theme_color:</strong> The main color for the app, used in the browser UI.</li>
        <li><strong>orientation:</strong> Defines screen orientation. Options include:
            <ul>
                <li><code>portrait</code>, <code>landscape</code>, or <code>any</code>.</li>
            </ul>
        </li>
        <li><strong>icons:</strong> A list of app icons with different sizes for various devices.</li>
        <li><strong>screenshots:</strong> Screenshots showing the app UI before installation.</li>
    </ul>
    
    <h3>10.2 Defining the Manifest File for the StudySync PWA</h3>
    <p>Below is an example of the <code>manifest.json</code> file for StudySync:</p>
    <pre><code>{
    "name": "StudySync",
    "short_name": "StudySync",
    "description": "A flashcard study reminder application",
    "start_url": "/",
    "background_color": "#ffffff",
    "theme_color": "#4a90e2",
    "display": "standalone",
    "orientation": "portrait-primary",
    "icons": [
        { "src": "/icons/72x72.png", "sizes": "72x72", "type": "image/png" },
        { "src": "/icons/96x96.png", "sizes": "96x96", "type": "image/png" },
        { "src": "/icons/128x128.png", "sizes": "128x128", "type": "image/png" },
        { "src": "/icons/192x192.png", "sizes": "192x192", "type": "image/png" },
        { "src": "/icons/512x512.png", "sizes": "512x512", "type": "image/png" }
    ],
    "screenshots": [
        { "src": "/screenshots/desktop.png", "sizes": "1200x800", "type": "image/png" },
        { "src": "/screenshots/mobile.png", "sizes": "750x1334", "type": "image/png" }
    ]
}</code></pre>

    <h3>10.3 Integrate the Manifest File in the PWA</h3>
    <p>To integrate the <code>manifest.json</code> file into your PWA, link it in the HTML file:</p>
    <pre><code>&lt;link rel="manifest" href="./manifest.json" /&gt;</code></pre>
    <p>Follow these steps to verify the manifest file in your browser:</p>
    <ol>
        <li>Run the Spring Boot server.</li>
        <li>Navigate to <a href="http://localhost:8080" target="_blank">http://localhost:8080</a>.</li>
        <li>Right-click on the page &rarr; Inspect &rarr; Application tab &rarr; Manifest section.</li>
    </ol>

    <h2 id="service-worker">11. Service Worker for Progressive Web Apps</h2>
    <p>A service worker is a JavaScript file that helps make a PWA reliable. It runs in the background, separate from the main app, and can handle tasks like caching resources, managing network requests, and enabling offline capabilities.</p>
    
    <h3>11.1 Lifecycle of a Service Worker</h3>
    <p>The lifecycle of a service worker involves the following phases:</p>
    <ol>
        <li><strong>Register:</strong> Register the service worker in the browser.</li>
        <li><strong>Install:</strong> Cache necessary files for the app to work offline.</li>
        <li><strong>Waiting:</strong> Wait until the current service worker is no longer controlling pages.</li>
        <li><strong>Activate:</strong> Clean up old caches and take control of the app.</li>
    </ol>

    <h3>11.2 Integrate Service Worker into StudySync PWA</h3>
    <p>Here is an example of registering the service worker in <code>app.js</code>:</p>
    <pre><code>if ("serviceWorker" in navigator) {
    window.addEventListener("load", async () => {
        try {
            const registration = await navigator.serviceWorker.register("./service-worker.js");
            console.log("ServiceWorker registered with scope:", registration.scope);
        } catch (error) {
            console.error("ServiceWorker registration failed:", error);
        }
    });
}</code></pre>
    <p><strong>Explanation:</strong></p>
    <ul>
        <li>Check if the browser supports service workers using <code>"serviceWorker" in navigator</code>.</li>
        <li>Register the service worker with the relative path to <code>service-worker.js</code>.</li>
        <li>Log the success or failure of the registration.</li>
    </ul>

    <p>Once registered, the service worker runs in the background, enabling offline caching and push notifications.</p>

    <h2 id="android">12. Running the Project on Android Emulator</h2>
    <p>To test the StudySync PWA on an Android emulator while running the Spring Boot application on localhost, follow these steps:</p>

    <h3>12.1 Prerequisites</h3>
    <p>Before starting, ensure you have the following:</p>
    <ul>
        <li>Android Studio installed on your development machine. Download it <a href="https://developer.android.com/studio" target="_blank">here</a>.</li>
    </ul>

    <h3>12.2 Setting Up Android Studio and AVD</h3>
    <p>Follow these steps to set up the Android Virtual Device (AVD):</p>
    <ol>
        <li>Open Android Studio.</li>
        <li>Go to <strong>Tools > Device Manager</strong>.</li>
        <li>Click on <strong>Create Device</strong>.</li>
        <li>Select a phone definition (e.g., Pixel 6).</li>
        <li>Choose a system image (recommended: API 30 or higher).</li>
        <li>Complete the AVD creation wizard.</li>
    </ol>

    <h3>12.3 Testing the PWA</h3>
    <p>Follow these steps to test the PWA on the Android emulator:</p>
    <ol>
        <li>Ensure your Spring Boot application is running on <code>localhost:8080</code>.</li>
        <li>Open the Chrome browser on the Android emulator.</li>
        <li>Navigate to <a href="http://localhost:8080" target="_blank">http://localhost:8080</a>.</li>
        <li>You should see the StudySync application loading.</li>
    </ol>

    <h2 id="caching">13. Service Worker Caching and Fetch Handling</h2>
    <p>In this section, we'll explore how to implement caching and network request handling in the StudySync PWA's service worker. This functionality is crucial for enabling offline access and improving performance.</p>

    <h3>13.1 Cache Configuration</h3>
    <p>First, define the cache name and assets that need to be cached:</p>
    <pre><code>const CACHE_NAME = "studysync-v1";
const ASSETS_TO_CACHE = [
    "./",
    "./index.html",
    "./styles.css",
    "./src/js/app.js",
    "./manifest.json",
    "./favicon.ico",
    "./src/js/managers/FlashcardManager.js",
    "./src/js/services/ApiService.js",
];</code></pre>
    <p>The <code>CACHE_NAME</code> serves as a version identifier for the cache. Change it to force a refresh of all cached content when updates are made.</p>

    <h3>13.2 Enhanced Installation Phase</h3>
    <p>Extend the installation phase to cache the required assets:</p>
    <pre><code>self.addEventListener("install", (event) => {
    event.waitUntil(
        Promise.all([
            self.skipWaiting(),
            caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS_TO_CACHE)),
        ])
    );
});</code></pre>
    <p><strong>Explanation:</strong></p>
    <ul>
        <li>The <code>skipWaiting()</code> method ensures the service worker activates immediately.</li>
        <li>Assets specified in <code>ASSETS_TO_CACHE</code> are pre-cached.</li>
    </ul>

    <h3>13.3 Cache Management During Activation</h3>
    <p>Manage and clean up old caches during the activation phase:</p>
    <pre><code>self.addEventListener("activate", (event) => {
    event.waitUntil(
        Promise.all([
            clients.claim(),
            caches.keys().then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (cacheName !== CACHE_NAME) {
                            return caches.delete(cacheName);
                        }
                    })
                );
            }),
        ])
    );
});</code></pre>
    <p><strong>Explanation:</strong></p>
    <ul>
        <li>Old caches that do not match the current <code>CACHE_NAME</code> are deleted.</li>
        <li>The <code>clients.claim()</code> method ensures the service worker takes control of all open clients immediately.</li>
    </ul>

    <h3>13.4 Fetch Request Handling</h3>
    <p>Implement a "Cache First" strategy for fetch requests:</p>
    <pre><code>self.addEventListener("fetch", (event) => {
    if (event.request.method !== "GET") return;

    event.respondWith(
        caches.match(event.request).then((response) => {
            if (response) return response;

            return fetch(event.request).then((networkResponse) => {
                if (networkResponse.ok && networkResponse.url.startsWith(self.location.origin)) {
                    const responseToCache = networkResponse.clone();
                    caches.open(CACHE_NAME).then((cache) => {
                        cache.put(event.request, responseToCache);
                    });
                }
                return networkResponse;
            });
        })
    );
});</code></pre>
    <p><strong>Explanation:</strong></p>
    <ul>
        <li>Only <code>GET</code> requests are handled.</li>
        <li>The service worker first checks for the resource in the cache.</li>
        <li>If not found, it fetches the resource from the network and caches it for future use.</li>
    </ul>

    <h3>13.5 Caching Strategy Explanation</h3>
    <p>The "Cache First" strategy provides the following benefits:</p>
    <ul>
        <li>Faster response times for cached resources.</li>
        <li>Offline access for previously cached content.</li>
        <li>Automatic cache updates with fresh content when online.</li>
    </ul>

    <h3>13.6 Testing Cache Implementation</h3>
    <p>Follow these steps to test the caching implementation:</p>
    <ol>
        <li>Open Chrome DevTools.</li>
        <li>Navigate to <strong>Application > Cache Storage</strong>.</li>
        <li>Verify that all specified assets are cached under the <code>studysync-v1</code> cache.</li>
        <li>Enable offline mode in DevTools and refresh the page.</li>
        <li>Confirm that the app still works as expected.</li>
    </ol>
    <p>By implementing this caching strategy, StudySync can:</p>
    <ul>
        <li>Load faster on repeat visits.</li>
        <li>Work offline or in poor network conditions.</li>
        <li>Automatically update cached resources when online.</li>
        <li>Manage cache versions effectively.</li>
    </ul>

    <h2 id="offline-storage">14. Implementing Offline Storage with IndexedDB</h2>
    <p>This section covers the implementation of offline storage capabilities in the StudySync PWA using IndexedDB, and the necessary modifications to the FlashcardManager to support offline functionality.</p>

    <h3>14.1 Database Manager Implementation</h3>
    <p>The <code>DatabaseManager</code> class handles all IndexedDB operations:</p>
    <pre><code>export class DatabaseManager {
    constructor() {
        this.db = null;
    }

    async initializeDb() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open("StudySyncDB", 1);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains("cards")) {
                    const store = db.createObjectStore("cards", { keyPath: "id" });
                    store.createIndex("userId", "userId", { unique: false });
                }
                if (!db.objectStoreNames.contains("syncQueue")) {
                    db.createObjectStore("syncQueue", {
                        keyPath: "id",
                        autoIncrement: true,
                    });
                }
            };
        });
    }

    async saveToStore(storeName, data) {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const request = store.put(data);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async getAllFromStore(storeName) {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
}</code></pre>

    <h3>14.2 Modified FlashcardManager for Offline Support</h3>
    <p>The <code>FlashcardManager</code> class integrates offline support using IndexedDB:</p>
    <pre><code>export class FlashcardManager {
    constructor(dbManager) {
        this.dbManager = dbManager;
        this.cards = [];
    }

    async loadCards() {
        try {
            this.cards = await this.dbManager.getAllFromStore("cards");
            this.renderCards();
        } catch (error) {
            console.error("Failed to load cards:", error);
        }
    }

    async createCard(front, back) {
        const card = { id: crypto.randomUUID(), front, back, timestamp: new Date() };
        await this.dbManager.saveToStore("cards", card);
        this.cards.push(card);
        this.renderCards();
    }

    renderCards() {
        // Code to render cards to the UI
    }
}</code></pre>
    <p><strong>Key Features:</strong></p>
    <ul>
        <li>Stores flashcard data in IndexedDB for offline access.</li>
        <li>Ensures cards are accessible even without internet.</li>
    </ul>

    <h2 id="sync-service">15. Implementing Sync Service and Application Architecture</h2>
    <p>This section explains how the <code>SyncService</code> synchronizes local data with the server when the app is back online.</p>

    <h3>15.1 Sync Service Implementation</h3>
    <p>The <code>SyncService</code> class manages data synchronization:</p>
    <pre><code>export class SyncService {
    constructor(dbManager, apiService) {
        this.dbManager = dbManager;
        this.apiService = apiService;
    }

    async syncWithServer() {
        const queue = await this.dbManager.getAllFromStore("syncQueue");

        for (const item of queue) {
            try {
                switch (item.operation) {
                    case "create":
                        await this.apiService.saveCard(item.data);
                        break;
                    case "delete":
                        await this.apiService.deleteCard(item.data.id);
                        break;
                }
                await this.dbManager.saveToStore("syncQueue", item);
            } catch (error) {
                console.error("Failed to sync data:", error);
            }
        }
    }
}</code></pre>
    <p><strong>Key Responsibilities:</strong></p>
    <ul>
        <li>Processes pending operations stored in <code>syncQueue</code>.</li>
        <li>Synchronizes data with the server when back online.</li>
    </ul>

    <h3>15.2 Enhanced Application Architecture</h3>
    <p>The updated <code>App</code> class incorporates offline capabilities, synchronization, and database management:</p>
    <pre><code>class App {
    async initialize() {
        // Initialize Service Worker
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", async () => {
                try {
                    const registration = await navigator.serviceWorker.register(
                        "./service-worker.js"
                    );
                    console.log("ServiceWorker registered:", registration.scope);
                } catch (error) {
                    console.error("ServiceWorker registration failed:", error);
                }
            });
        }

        // Initialize Database
        const dbManager = new DatabaseManager();
        await dbManager.initializeDb();

        // Initialize Services
        const apiService = new ApiService();
        const syncService = new SyncService(dbManager, apiService);

        // Initialize FlashcardManager
        this.flashcardManager = new FlashcardManager(dbManager);
        this.flashcardManager.loadCards();

        // Perform initial synchronization
        syncService.syncWithServer();
    }
}</code></pre>

    <p><strong>Key Steps in Initialization:</strong></p>
    <ol>
        <li>Registers the service worker to enable offline support.</li>
        <li>Initializes the IndexedDB database using the <code>DatabaseManager</code> class.</li>
        <li>Sets up the API service and sync service to manage server communication.</li>
        <li>Loads cards from local storage into the UI using <code>FlashcardManager</code>.</li>
        <li>Performs an initial synchronization with the server to update data.</li>
    </ol>

    <h3>15.3 Key Components and Their Interactions</h3>
    <p>The StudySync PWA architecture is built around the following key components:</p>
    <ul>
        <li><strong>Database Manager:</strong>
            <ul>
                <li>Manages all operations with IndexedDB.</li>
                <li>Handles two object stores: <code>cards</code> (for flashcard data) and <code>syncQueue</code> (for pending operations).</li>
            </ul>
        </li>
        <li><strong>Sync Service:</strong>
            <ul>
                <li>Manages data synchronization between the client and server.</li>
                <li>Processes operations in the <code>syncQueue</code> when the app is online.</li>
            </ul>
        </li>
        <li><strong>API Service:</strong>
            <ul>
                <li>Handles all communication with the backend server.</li>
                <li>Provides CRUD operations for managing flashcard data on the server.</li>
            </ul>
        </li>
        <li><strong>Flashcard Manager:</strong>
            <ul>
                <li>Manages flashcard data and UI rendering.</li>
                <li>Integrates with the <code>DatabaseManager</code> for offline storage.</li>
            </ul>
        </li>
        <li><strong>Service Worker:</strong>
            <ul>
                <li>Handles caching for offline access.</li>
                <li>Intercepts network requests and serves cached resources when offline.</li>
            </ul>
        </li>
    </ul>

    <h3>15.4 Component Interaction Diagram</h3>
    <p>The following diagram describes how the components interact in the StudySync PWA:</p>
    <ul>
        <li>User interacts with the <strong>FlashcardManager</strong> to create, delete, or update flashcards.</li>
        <li>The <strong>FlashcardManager</strong> saves data to <strong>IndexedDB</strong> using the <code>DatabaseManager</code>.</li>
        <li>When online, the <strong>SyncService</strong> processes pending operations from <code>syncQueue</code> and syncs them to the server via the <strong>ApiService</strong>.</li>
        <li>The <strong>Service Worker</strong> caches resources and enables offline functionality.</li>
    </ul>

    <h2 id="references">16. References</h2>
    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Guides/Making_PWAs_installable" target="_blank">Making PWAs Installable - MDN Web Docs</a></li>
        <li><a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank">Progressive Apps: Escaping Tabs Without Losing Our Soul - Infrequently.org</a></li>
        <li><a href="https://medium.com/progressivewebapps/history-of-progressive-web-apps-4c912533a531" target="_blank">History of Progressive Web Apps - Medium</a></li>
        <li><a href="https://www.apple.com/newsroom/2008/07/14iPhone-App-Store-Downloads-Top-10-Million-in-First-Weekend/" target="_blank">iPhone App Store Downloads Top 10 Million in First Weekend - Apple</a></li>
        <li><a href="https://www.forbes.com/sites/markrogowsky/2014/07/11/app-store-at-6-how-steve-jobs-biggest-blunder-became-one-of-apples-greatest-strengths/#4b471804652b" target="_blank">App Store at 6: How Steve Jobs' Biggest Blunder Became One of Apple's Greatest Strengths - Forbes</a></li>
        <li><a href="https://web.dev/explore/progressive-web-apps" target="_blank">Explore Progressive Web Apps - web.dev</a></li>
        <li><a href="https://web.dev/articles/service-worker-lifecycle" target="_blank">Service Worker Lifecycle - web.dev</a></li>
        <li><a href="https://www.youtube.com/watch?v=NhQfvZoRb2Q" target="_blank">PWA Tutorial for Beginners - YouTube</a></li>
        <li><a href="https://www.youtube.com/watch?v=gTrVzfFTr68" target="_blank">Service Worker Lifecycle - YouTube</a></li>
    </ul>
</body>
</html>